[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "مبانی پایتون",
    "section": "",
    "text": "پیش گفتار\nبه همراه این کتاب می‌توانید یادگیری پایتون را شروع کنید. سعی کنید بعد از هر آموزش تمرینات مربوط به آن را انجام دهید. نظرات و پیشنهادات خود را می‌توانید از طریق ایمیل mhb.s.katebi@gmail.com و mohsenebrahimy.ir@gmail.com برای بهبود کتاب به نویسنده ارسال کنید تا در هر بروزرسانی اصلاحات صورت گیرد. این نسخه در تاریخ ۱۴۰۳-۱۰-۲۳ بروزرسانی شده است.\n\nامیدوارم این کتاب برایتان مفید باشد.\n\nکتاب: https://mohsenebrahimyir.github.io/base-python/\n\n\n\n\n\n\n\nهشدار\n\n\n\nاگر این متن را میبینید یعنی این کتاب درحال توسعه است.",
    "crumbs": [
      "پیش گفتار"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "مقدمه",
    "section": "",
    "text": "معماری سخت افزار کامپیوتر\nاگر ما در ابتدای ورود به مسیر برنامه‌نویسی هستیم، بهتر است کمی درمورد اینکه کامپیوتر چگونه کار می‌کند، صحبت کنیم. خوب است بدانیم، قسمت‌های مختلف یک کامپیوتر به زبان بسیار ساده، به این ترتیب هستند:\nتعاریف سطح بالای این قطعات به شرح زیر است:\nو ما به عنوان یک برنامه‌نویس مسئول این هستیم که به CPU بگوئیم چه زمانی چه کاری انجام دهد و از کدام دستگاه‌های ورودی و خروجی استفاده کند. به این ترتیب، ما همه این منابع را باهم هماهنگ می‌سازیم.",
    "crumbs": [
      "مقدمه"
    ]
  },
  {
    "objectID": "intro.html#computer-hardware-architect",
    "href": "intro.html#computer-hardware-architect",
    "title": "مقدمه",
    "section": "",
    "text": "معماری سخت افزار کامپیوتر\n\n\n\n\nپردازنده مرکزی یا Central Processing Unit (CPU): می‌تواند در هر ثانیه چندین کار را انجام دهد طوری که ما احساس کنیم کارها بطور موازی انجام می‌شوند. اینکه چه تعداد کار را در یک ثانیه انجام دهد، به سرعت پردازنده ما بستگی دارد. بطور مثال، اگر سرعت پردازنده ما 3.0 گیگاهرتز (3.0 Gigahertz) باشد، به معنی این است که به تعداد سه میلیارد کار در هر ثانیه، می‌تواند انجام دهد.\nحافظه اصلی یا Main Memory: برای ذخیره و دردسترس قرار دادن اطلاعات ضروری و مورد نیاز سریع پردازنده مرکزی، بکار می‌رود. اما باید مراقب اطلاعات خود در حافظه اصلی باشیم، چرا که با خاموش شدن کامپیوتر و یا راه‌اندازی مجدد (restart) اطلاعات آن از بین می‌رود.\nحافظه ثانویه یا (Secondary Memory): این نوع حافظه برای ذخیره دائمی اطلاعات بکارمی‌رود، اما سرعت آن از سرعت حافظه اصلی کمتر است.\nدستگاه‌های ورودی و خروجی یا (Input and Output Devices): همان وسایلی هستند که به کمک آن‌ها با کامپیوتر ارتباط برقرار می‌کنیم، شامل صفحه کلید، مانیتور، ماوس و …",
    "crumbs": [
      "مقدمه"
    ]
  },
  {
    "objectID": "intro.html#انواع-زبان-های-برنامه-نویسی",
    "href": "intro.html#انواع-زبان-های-برنامه-نویسی",
    "title": "مقدمه",
    "section": "انواع زبان های برنامه نویسی",
    "text": "انواع زبان های برنامه نویسی\n\n\n\nانقلاب زبان‌های برنامه نویسی\n\n\n\nزبان انسان (English)\nزبان‌های برنامه نویسی سطح بالا (C, C++, R, Python)\nزبان برنامه نویسی سطح پایین (Assembly)\nزبان ماشین (01)\n\n\nنکته. در نهایت اکثر زبان‌های برنامه نویسی منطق یکسانی دارند و یا دگیری یک زبان برنامه نویسی، یادگیری زبان برنامه نویسی دیگر را ساده تر می‌کند.\n\nسایت تبدیل زبان برنامه نویسی R به زبان برنامه نویسی Assembly https://www.codeconvert.ai/r-to-assembly-converter\n\nخروجی\n\n    name Age\n1 Mohsen  30\n2  Arash  12\n\nR\n\ndf = data.frame(\n  \"name\" = c(\"Mohsen\", \"Arash\"),\n  \"Age\" = c(30, 12)\n)\n\nprint(df)\n\nMatlab\n\ndf = table;\ndf.name = {'Mohsen', 'Arash'};\ndf.Age = [30, 12];\n\ndisp(df)\n\nPython\n\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"name\": [\"Mohsen\", \"Arash\"],\n    \"Age\": [30, 12]\n})\n\nprint(df)\n\nSas\n\ndata df;\n  input name $ age;\ndatalines;\nMohsen 30\nArash 12\n;\nrun;\n\nproc print data=df;\nrun;\n\nFortran\n\nPROGRAM main\n  IMPLICIT NONE\n  \n  INTEGER :: i\n  CHARACTER(LEN=10), DIMENSION(2) :: name\n  INTEGER, DIMENSION(2) :: age\n  \n  name(1) = \"Mohsen\"\n  name(2) = \"Arash\"\n  age(1) = 30\n  age(2) = 12\n  \n  DO i = 1, 2\n    WRITE(*,*) \"name: \", name(i), \", age: \", age(i)\n  END DO\nEND PROGRAM main\n\nC\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nint main() {\n    std::vector&lt;std::string&gt; name = {\"Mohsen\", \"Arash\"};\n    std::vector&lt;int&gt; Age = {30, 12};\n\n    std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt; df;\n    df[\"name\"] = name;\n    df[\"Age\"] = Age;\n\n    for (const auto& pair : df) {\n        std::cout &lt;&lt; pair.first &lt;&lt; \": \";\n        for (const auto& value : pair.second) {\n            std::cout &lt;&lt; value &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n\nAssembly\n\nasm\n.data\ndf_name_data:\n    .asciz \"Mohsen\"\n    .asciz \"Arash\"\ndf_age_data:\n    .int 30\n    .int 12\ndf_nrows = 2\ndf_ncols = 2\n\n.text\n.globl main\nmain:\n    # Allocate memory for the data frame\n    movl $df_nrows, %eax\n    movl $df_ncols, %ebx\n    imull %ebx, %eax\n    shl $2, %eax # Each element is 4 bytes (int)\n    pushl %eax\n    call malloc\n    popl %ecx\n    movl %eax, %edi # edi points to the data frame\n\n    # Copy the name data\n    movl $df_name_data, %esi\n    movl $0, %ecx\nloop1:\n    cmpl $df_nrows, %ecx\n    je end1\n    movl (%esi), %eax\n    movl %eax, (%edi)\n    addl $4, %edi # Move to the next column\n    addl $4, %esi # Move to the next name\n    incl %ecx\n    jmp loop1\nend1:\n\n    # Copy the age data\n    movl $df_age_data, %esi\n    movl $0, %ecx\nloop2:\n    cmpl $df_nrows, %ecx\n    je end2\n    movl (%esi), %eax\n    movl %eax, (%edi)\n    addl $4, %edi # Move to the next column\n    addl $4, %esi # Move to the next age\n    incl %ecx\n    jmp loop2\nend2:\n\n    # Print the data frame\n    movl $df_nrows, %eax\n    movl $df_ncols, %ebx\n    imull %ebx, %eax # Total number of elements\n    movl %edi, %ebx # ebx points to the start of the data frame\n    movl $0, %ecx\nloop3:\n    cmpl %eax, %ecx\n    je end3\n    # Print the current element\n    pushl (%ebx)\n    pushl $format\n    call printf\n    addl $8, %esp\n    addl $4, %ebx # Move to the next element\n    incl %ecx\n    jmp loop3\nend3:\n\n    # Free the memory\n    movl %edi, %eax\n    call free\n\n    xorl %eax, %eax\n    ret\n\n.data\nformat:\n    .asciz \"%d \"",
    "crumbs": [
      "مقدمه"
    ]
  },
  {
    "objectID": "intro.html#کاربرد-هر-زبان-برنامه-نویسی",
    "href": "intro.html#کاربرد-هر-زبان-برنامه-نویسی",
    "title": "مقدمه",
    "section": "کاربرد هر زبان برنامه نویسی",
    "text": "کاربرد هر زبان برنامه نویسی\n\nنگاهی به نظر برنامه نویسان\n\nhttps://survey.stackoverflow.co/\n\n\nکل داده‌ها\nدر این شکل توزیع کشورهای افراد شرکت کننده را ترسیم نمودیم (بعضی افراد از اظهار کشورشان امتناع کردند که از داده‌ها حذف شده‌اند)\n\n\n\nتوزیع کشورهای توسعه دهندگان شرکت کننده در نظرسنجی جهانی\n\n\n\n\nتوسعه دهندگان فیلتر شده\nبا توجه به داده‌های موجود در نظر سنجی برای دقت بیشتر و تحلیل بهتر نتایج، بخشی از شرکت کننده‌ها فیلتر شده‌اند.\nشرایط توسعه دهندگانی که برای تحلیل انتخاب شده‌اند.\n\nافراد بالای ۲۵ سال سن\nافراد با بیش از ۵ سال سابقه برنامه نویسی حرفه‌ای\nافراد شاغل (تمام یا نیمه وقت) یا خود اشتغال\nافرادی که از انواع گزینه‌های توسعه دهنده کمتر از ۳ گزینه انتخاب نمودند.\n\n\n\n\nتوزیع کشورهای توسعه دهندگان فیلتر شده شرکت کننده در نظرسنجی جهانی\n\n\n\n\nانواع توسعه دهندگان\n\n\n\nانواع توسعه دهندگان\n\n\n\n\n\nده زبان برنامه نویسی برتر\n\nنگاه کلی\n\n\n\nده زبان برنامه نویسی برتر-نگاه کلی\n\n\n\n\nنرم افزار\n\n\n\nده زبان برنامه نویسی برتر-توسعه دهندگان نرم افزار\n\n\n\n\nوبسایت (بک‌اند-فرانت-اند)\n\n\n\nده زبان برنامه نویسی برتر-توسعه دهندگان وبسایت\n\n\n\n\nبازی سازی\n\n\n\nده زبان برنامه نویسی برتر-توسعه دهندگان بازی\n\n\n\n\nموبایل\n\n\n\nده زبان برنامه نویسی برتر-توسعه دهندگان موبایل\n\n\n\n\nدانشمند داده و یادگیری ماشین\n\n\n\nده زبان برنامه نویسی برتر-توسعه دهندگان داده و یادگیری ماشین\n\n\n\n\n\nزبان برنامه نویسی برای شروع\n\n\n\nچه زبان برنامه نویسی را باید اول یاد بگیریم؟\n\n\n\n\nچرا پایتون\nشاید دلیل ما برای شروع یادگیری پایتون این باشد که ن یاز به آنالیز داده‌های زیادی داریم، یا برای امرار معاش به این راه وارد شده‌ایم. همچنین اگر در حوزه علم داده (Data Science) و یا هوش مصنوعی (Artificial Intelligence) مشغول به فعالیت هستیم، زبان برنامه‌نویسی پایتون، گزینه بسیار مناسبی برای ما خواهد بود.\nدر نهایت اینکه ممکن است به یکی از دلایل زیر، ما نیاز به یادگیری پایتون داشته باشیم:\n1- اسکریپت و اتوماسیون در پایتون\n2- استفاده از پایتون برای داده‌های بزرگ (Big Data)\n3- پشتیبانی پایتون از تست (Testing)\n4- گرافیک کامپیوتری در پایتون\n5- استفاده از پایتون در توسعه وب\n6- سازگار و قابل انتقال بودن\n7- تفسیر داده‌های تصویربرداری عصبی\n8- بهره‌مندی از پایتون در طراحی Task در نرم‌افزارهایی مانند Psychopy\n\n\n\n\n[1] C. R. Severance, S. Blumenberg, and E. Hauser, Python for everybody: Exploring data in python 3. North Charleston, SC, USA: CreateSpace Independent Publishing Platform, 2016.",
    "crumbs": [
      "مقدمه"
    ]
  },
  {
    "objectID": "chapter/01-python-programming.html",
    "href": "chapter/01-python-programming.html",
    "title": "برنامه نویسی پایتون",
    "section": "",
    "text": "نصب پایتون و اجرای کد\nhttps://www.python.org/",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>برنامه نویسی پایتون</span>"
    ]
  },
  {
    "objectID": "chapter/01-python-programming.html#نصب-پایتون-و-اجرای-کد",
    "href": "chapter/01-python-programming.html#نصب-پایتون-و-اجرای-کد",
    "title": "برنامه نویسی پایتون",
    "section": "",
    "text": "python --version\nPython 3.10.12",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>برنامه نویسی پایتون</span>"
    ]
  },
  {
    "objectID": "chapter/01-python-programming.html#نصب-ide",
    "href": "chapter/01-python-programming.html#نصب-ide",
    "title": "برنامه نویسی پایتون",
    "section": "نصب IDE",
    "text": "نصب IDE\n\n\n\nنظر سنجی ۲۰۲۳ از توسعه دهندگان درباره محیط توسعه یکپارچه [1]\n\n\nبرای نوشتن، اجرا و خروجی گرفتن بهتر می‌توانید از یک نرم افزار IDE (Integrated Development Environment) استفاده کنید.\n\nنصب VSCode از https://code.visualstudio.com/\nنصب Jupyter از https://jupyter.org",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>برنامه نویسی پایتون</span>"
    ]
  },
  {
    "objectID": "chapter/01-python-programming.html#interpreter-and-compiler",
    "href": "chapter/01-python-programming.html#interpreter-and-compiler",
    "title": "برنامه نویسی پایتون",
    "section": "مترجم و کامپایلر",
    "text": "مترجم و کامپایلر\nپایتون یک زبان سطح بالا محسوب می‌شود. به این معنی که به زبان انسان نزدیک‌تر است تا به زبان سخت‌افزار کامپیوتر. اما مفهوم دستورات زبان‌های سطح بالا توسط CPU قابل فهم نیست. چرا که CPU فقط دستوراتی که به زبان ماشین نوشته شده باشند را درک می‌کند. زبان ماشین از دو نشانه 0 و 1 تشکیل شده است و CPU قادر است تنها همین زبان را بفهمد و دستورات آن را اجرا کند:\n00101000111010010010101000000111\n11100110000011101010010101101101\n...\nپس برنامه‌های زبان‌های سطح بالایی مثل پایتون را چگونه باید برای CPU شرح داد؟\nمترجم‌های متعددی برای ترجمه و تبدیل کدهای زبان سطح بالا به زبان سطح ماشین، وجود دارد. اما از آن‌جایی که زبان ماشین کاملا وابسته به سخت‌افزار کامپیوتر است، بنابراین ما یک زبان ماشین که بتواند با انواع سخت‌افزار هماهنگ شود را نداریم. برنامه‌های نوشته شده به زبان‌های سطح بالا را می‌توان با استفاده از یک مفسر متفاوت در ماشین (همان سخت‌افزار) جدید یا کامپایل مجدد کد برای ایجاد نسخه زبان ماشین برنامه موردنظر برای ماشین جدید بین رایانه های مختلف جابجا کرد.\nاین مترجمان زبان برنامه‌نویسی به دو دسته کلی تقسیم می شوند:\n\nمفسر (Interpreter)\nکامپایلر (Compiler)\n\nیک مفسر کد برنامه نوشته شده توسط برنامه‌نویس را خوانده، آن را تجزیه می‌کند و دستورالعمل‌ها را تفسیر می‌نماید. با این توصیف، پایتون یک مفسر محسوب می‌شود که کدهای برنامه ما رافوراً پردازش می‌کند.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>برنامه نویسی پایتون</span>"
    ]
  },
  {
    "objectID": "chapter/01-python-programming.html#سایتهای-مفید",
    "href": "chapter/01-python-programming.html#سایتهای-مفید",
    "title": "برنامه نویسی پایتون",
    "section": "سایت‌های مفید",
    "text": "سایت‌های مفید\n\nاستفاده از سایت گوگل (www.google.com)\n\n\nنکته. بهترین مهارت برای یک برنامه نویس مهارت گوگل کردن است.\n\n\nپرسیدن و جستجوی سوالات در سایت (stackoverflow.com)\n\n\nنکته. سعی کنید در ابتدای کار کل کدها را تایپ کنید و بدون فهم درست از کدها چیزی را کپی نکنید.\n\n\nاستفاده از هوش مصنوعی\n\nchat GPT\nGemeni\nCodeium\n\n\n\nنکته. در استفاده از هوش مصنوعی افراطی عمل نکنید و نسبت به عملکرد کدها اطمینان حاصل فرمایید.\n\n\nنکته. برای عبور از مشکلات تحریمی میتوانید از دی ان اس های سایت شکن استفاده نمایید.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>برنامه نویسی پایتون</span>"
    ]
  },
  {
    "objectID": "chapter/01-python-programming.html#تمرین",
    "href": "chapter/01-python-programming.html#تمرین",
    "title": "برنامه نویسی پایتون",
    "section": "تمرین",
    "text": "تمرین\n\n\n\nمنحنی یادگیری ابزارهای آماری [2]\n\n\nبرای تمرین بیشتر می‌توانید از سایت‌هایی که تمرینات python ارائه می‌دهند استفاده کنید.\nبا جستجو python exercises with solutions در گوگل به سایت‌های زیر دسترسی پیدا می‌کنید\n\nکوئرا\nCode Wars\nW3Schools\nکمک کردن به دیگران\nمشارکت در پروژه‌ی دیگران\n\n\n\n\n\n[1] “Stack over flow - 2023 developer survey.” https://survey.stackoverflow.co/2023/\n\n\n[2] “New york university - statistic software.” https://guides.nyu.edu/quant/statsoft",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>برنامه نویسی پایتون</span>"
    ]
  },
  {
    "objectID": "chapter/02-variables-expressions-commands.html",
    "href": "chapter/02-variables-expressions-commands.html",
    "title": "متغیرها، عبارات و دستورات",
    "section": "",
    "text": "عبارات بولی\nعبارت بولی (Boolean expressions) عبارتی است که یا درست یا نادرست است. عملگر== برای مقایسه دو عملوند بکار می‌رود و نتیجه آن درستی (True) یا نادرستی (False) نتیجه این ارزیابی را نشان می‌دهد:\nعملگر == یکی از عملگرهای مقایسه‌ای است، سایر عملگرها عبارتند از:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>متغیرها، عبارات و دستورات</span>"
    ]
  },
  {
    "objectID": "chapter/02-variables-expressions-commands.html#boolean-expressions",
    "href": "chapter/02-variables-expressions-commands.html#boolean-expressions",
    "title": "متغیرها، عبارات و دستورات",
    "section": "",
    "text": "5 == 5\nTrue\n5 == 6\nFalse\n\nx != y        # x is not equal to y\nx &gt; y         # x is greater than y\nx &lt; y         # x is less than y\nx &gt;= y        # x is greater than or equal to y\nx &lt;= y        # x is less than or equal to y\nx is y        # x is the same as y\nx is not y    # x is not the same as y",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>متغیرها، عبارات و دستورات</span>"
    ]
  },
  {
    "objectID": "chapter/02-variables-expressions-commands.html#logical-operators",
    "href": "chapter/02-variables-expressions-commands.html#logical-operators",
    "title": "متغیرها، عبارات و دستورات",
    "section": "عملگرهای منطقی",
    "text": "عملگرهای منطقی\nسه عملگر منطقی (Logical Operators) وجود دارد: and, or و not . برای مثال:\nx &gt; 0 and x &lt; 10\nعملوندهای عملگرهای منطقی باید عبارات بولی باشند، اما در پایتون هر عدد غیر صفر نیز به صورت True تفسیر می‌شود.\n17 and True\nTrue",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>متغیرها، عبارات و دستورات</span>"
    ]
  },
  {
    "objectID": "chapter/03-condition-statement.html",
    "href": "chapter/03-condition-statement.html",
    "title": "اجرای شرطی",
    "section": "",
    "text": "اجرای شرطی\nبرای نوشتن یک برنامه کارآ، خیلی اوقات نیاز به بررسی شرایط مختلف داریم که براساس آن‌ها رفتارهای متفاوتی را طراحی کنیم. با استفاده از جملات شرطی (Conditional Statements) می‌توانیم این قابلیت را بدست آوریم.\nعبارت منطقی پس از if ، شرط یا (condition) نامیده می‌شود. اگر شرط منطقی درست باشد، دستور تورفتگی اجرا می‌شود. اگر شرط منطقی نادرست باشد، عبارت تورفتگی نادیده گرفته می‌شود.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>اجرای شرطی</span>"
    ]
  },
  {
    "objectID": "chapter/03-condition-statement.html#condition-execution",
    "href": "chapter/03-condition-statement.html#condition-execution",
    "title": "اجرای شرطی",
    "section": "",
    "text": "if x &gt; 0 :\n    print('x is positive')",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>اجرای شرطی</span>"
    ]
  },
  {
    "objectID": "chapter/03-condition-statement.html#alternative-execution",
    "href": "chapter/03-condition-statement.html#alternative-execution",
    "title": "اجرای شرطی",
    "section": "اجرای جایگزین",
    "text": "اجرای جایگزین\nشکل دوم یک عبارت if اجرای جایگزین (Alternative Execution) است که در آن دو حالت ممکن توسط شرط بررسی می‌شود که کدامیک می‌بایست اجرا شوند:\nif x%2 == 0 :\n    print('x is even')\nelse :\n    print('x is odd')\nز آنجایی که شرط باید درست یا نادرست باشد، دقیقاً یکی از گزینه‌ها اجرا می‌شود. گزینه‌های جایگزین شاخه (Branch) نامیده می‌شوند، زیرا آنها شاخه‌هایی در جریان اجرا هستند.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>اجرای شرطی</span>"
    ]
  },
  {
    "objectID": "chapter/03-condition-statement.html#chained-conditionals",
    "href": "chapter/03-condition-statement.html#chained-conditionals",
    "title": "اجرای شرطی",
    "section": "شرط‌های زنجیره‌ای",
    "text": "شرط‌های زنجیره‌ای\nیکی از راه‌های بررسی بیش از سه شرط این است که با استفاده از elif از شرط‌های زنجیری (Chained Conditionals) استفاده کنیم:\nif x &lt; y:\n    print('x is less than y')\nelif x &gt; y:\n    print('x is greater than y')\nelse:\n    print('x and y are equal')",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>اجرای شرطی</span>"
    ]
  },
  {
    "objectID": "chapter/03-condition-statement.html#nested-conditionals",
    "href": "chapter/03-condition-statement.html#nested-conditionals",
    "title": "اجرای شرطی",
    "section": "شرط‌های تو در تو",
    "text": "شرط‌های تو در تو\nیک عبارت شرطی نیز می‌تواند درون عبارت شرطی دیگری قرار گیرد و ساختار شرط‌های تو در تو (Nested Conditionals) را ایجاد کنند:\nif x == y:\n    print('x and y are equal')\nelse:\n    if x &lt; y:\n        print('x is less than y')\n    else:\n        print('x is greater than y')",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>اجرای شرطی</span>"
    ]
  },
  {
    "objectID": "chapter/03-condition-statement.html#try-except-statement",
    "href": "chapter/03-condition-statement.html#try-except-statement",
    "title": "اجرای شرطی",
    "section": "استفاده از try و except",
    "text": "استفاده از try و except\nبرخی اوقات در جریان برنامه‌نویسی شرطی، نیاز داریم که به مفسر پایتون بگوئیم براساس ورودی‌های مختلف چگونه رفتار کند تا کد برنامه ما با خطا رویرو نشود. مثلاً در برنامه از کاربر خواستیم مقداری عددی وارد کند و بر اساس این مقدار، قرار است محاسبه‌ای انجام گیرد. حال فرض کنید کاربر مقداری غیر عددی وارد کرد و آنگاه این مقدار غیرعددی در یک فرمول محاسباتی وارد می‌شود! چه اتفاقی می‌افتد؟ مفسر پایتون اجرای برنامه را قطع می‌کند، چرا که نتوانسته است مقدار غیرعددی را در محاسبات وارد کند.\nدر این مواقع استفاده از ساختار try-except می‌تواند کمک‌کننده باشد:\ninp = input('Enter Fahrenheit Temperature:')\ntry:\n    fahr = float(inp)\n    cel = (fahr - 32.0) * 5.0 / 9.0\n    print(cel)\nexcept:\n    print('Please enter a number')\nدر اینجا پایتون کار را با اجرای دستور try آغاز می‌کند و اگر همه چیز خوب باشد، بلاک except را درنظر نمی‌گیرد. اما اگر استثنایی در بلاک try رخ داد، مفسر پایتون از بلاک try عبور می‌کند و به اجرای بلاک except می‌پردازد.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>اجرای شرطی</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html",
    "href": "chapter/04-functions.html",
    "title": "توابع",
    "section": "",
    "text": "فراخوانی تابع\nدر حوزه برنامه‌نویسی، یک تابع دنباله‌ای از جملات است که یک محاسبات را انجام می‌دهد. درواقع ما با تعیین یک نام و یک سری دستورات، می‌توانیم یک تابع را تعریف کنیم و آنگاه با صداکردن نام آن تابع، خواهیم توانست آن را فراخوانی کنیم. بسیاری از دستوراتی را که تابحال از آن‌ها استفاده می‌کردیم، درواقع تابع بودند:\nکه در این جا نام تابع type است.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#import-function",
    "href": "chapter/04-functions.html#import-function",
    "title": "توابع",
    "section": "",
    "text": "type(32)\n&lt;class 'int'&gt;",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#built-in-functions",
    "href": "chapter/04-functions.html#built-in-functions",
    "title": "توابع",
    "section": "توابع داخلی",
    "text": "توابع داخلی\nتوابع داخلی (Built-in) این‌ها توابعی هستند که توسط سازندگان پایتون تعبیه شده‌اند و برای حل مسائل عمومی مورد استفاده قرار می‌گیرند.\nنمونه‌ای از این توابع عبارتند از:\nmax('Hello world')\n'w'\nmin('Hello world')\n' '\nlen('Hello world')\n11",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#type-conversion-functions",
    "href": "chapter/04-functions.html#type-conversion-functions",
    "title": "توابع",
    "section": "توابع تبدیل نوع",
    "text": "توابع تبدیل نوع\nتوابع تبدیل نوع (Type Conversion) این‌ها نوع دیگری از توابع داخلی هستند که مقدار یک نوع را به نوعی دیگر تبدیل می‌کنند:\nint(3.99999)\n3\nint(-2.3)\n-3\nfloat('3.14159')\n3.14159",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#math-functions",
    "href": "chapter/04-functions.html#math-functions",
    "title": "توابع",
    "section": "توابع ریاضی",
    "text": "توابع ریاضی\nپایتون دارای یک ماژول ریاضی است که اکثر توابع ریاضی مشهور را ارائه می‌دهد. اما قبل از اینکه بتوانیم از ماژول استفاده کنیم، باید آن را وارد (import) کنیم:\nimport math\nاین عبارت یک شی ماژول به نام math ایجاد می کند.\nبرای دسترسی به یکی از توابع، باید نام ماژول و نام تابع را که با یک نقطه از هم جدا شده اند (که به عنوان نقطه نیز شناخته می شود) مشخص کنیم. به این فرمت، علامت نقطه می گویند.\nratio = signal_power / noise_power\ndecibels = 10 * math.log10(ratio)\nradians = 0.7\nheight = math.sin(radians)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#random-numbers",
    "href": "chapter/04-functions.html#random-numbers",
    "title": "توابع",
    "section": "اعداد تصادفی",
    "text": "اعداد تصادفی\nبه نظر می‌رسد که ساختن یک برنامه واقعاً غیر قطعی چندان آسان نیست، اما راه‌هایی وجود دارد که حداقل غیرقطعی به نظر برسد. یکی از آنها استفاده از الگوریتم‌هایی است که اعداد شبه تصادفی (Random) تولید می‌کنند. درست است که اعداد شبه تصادفی واقعاْ تصادفی نیستند اما بازهم تمایز آن‌ها از اعداد تصادفیُ غیرممکن است.\nماژول random توابعی را بدست می‌دهد که اعداد تصادفی تولید می‌کنند.\nیک مثال را باهم ببینیم:\nimport random\n\nfor i in range(10):\n    x = random.random()\n    print(x)\n0.0920530236235576\n0.6250171315179012\n0.7706549349232131\n0.7402147110407385\n0.15988207593735793\n0.4024047009691475\n0.8179640452074257\n0.44502244153994786\n0.8980030614870437\n0.9357510761663985\nاین برنامه یک لیستی از اعداد تصادفی بین 0 و 1 تولید می‌کند که شامل 1 نمی‌شوند:\nمثال‌هایی دیگر از توابع random‌ عبارتند از:\nrandom.randint(5, 10)\n7\nt = [1, 2, 3]\nrandom.choice(t)\n3",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#create-new-function",
    "href": "chapter/04-functions.html#create-new-function",
    "title": "توابع",
    "section": "افزودن یک تابع جدید",
    "text": "افزودن یک تابع جدید\nما معمولاْ برای پیشبرد اهداف برنامه موردنظرمان، نیاز به تعریف توابع جدید خواهیم داشت. این توابع در آینده بارها و بارها می‌توانند مورد استفاده قرار گیرند.\nدر مثال زیر، یک تابع به نام print_lyrics تعریف می‌کنیم:\ndef print_lyrics():\n    print(\"I'm a lumberjack, and I'm okay.\")\n    print('I sleep all night and I work all day.')\nهمانطور که در این مثال می‌بینید، کلمه کلیدی def برای تعریف تابع بکار برده می‌شود. با تعریف یک تابع، یک متغیر با همان نام ایجاد می‌شود. نحو فراخوانی تابع جدید مانند توابع داخلی است:\nprint_lyrics()\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day.\nما حتی می‌توانیم یک تابع تعریف شده را درون تابع دیگر، فراخوانی کنیم.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#parameters-and-arguments",
    "href": "chapter/04-functions.html#parameters-and-arguments",
    "title": "توابع",
    "section": "پارامترها و آرگومان‌ها",
    "text": "پارامترها و آرگومان‌ها\nبرخی از توابع داخلی که دیده‌ایم به آرگومان نیاز دارند. برای مثال، وقتی تابع math.sin را فراخوانی می‌کنیم، باید یک عدد را به آن بدهیم. به این ورودی، آرگومان (Argument)\nگفته می‌شود.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/04-functions.html#fruitful-functions-and-void-functions",
    "href": "chapter/04-functions.html#fruitful-functions-and-void-functions",
    "title": "توابع",
    "section": "توابع دارای خروجی و توابع بدون خروجی",
    "text": "توابع دارای خروجی و توابع بدون خروجی\nدر اجرای برخی توابع، با اتمام آخرین دستور تابع، مقداری را به عنوان نتیجه در خروجی می‌بینیم. این توابع را Fruitful می‌نامند:\nimport math\n\nmath.sqrt(5)\n2.23606797749979\nاما این اتفاق برای همه توابع رخ نمی‌دهد. درواقع این توابع کاری را انجام داده‌اند که بصورت خروجی قابل نمایش نیست. این توابع را Void می‌نامند:\ndef No_reult_func ():\n    x = math.cos(radians)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>توابع</span>"
    ]
  },
  {
    "objectID": "chapter/05-iteration.html",
    "href": "chapter/05-iteration.html",
    "title": "تکرار",
    "section": "",
    "text": "عبارت while\nبرای شروع آشنایی با عبارت و در حقیقت ساختار while به مثال زیر توجه کنید:\nبه این معنی که “تا وقتی که n بزرگتر از 0 است، مقدار n را نمایش بده و سپس مقدار n را به اندازه 1 واحد کاهش بده.\nوقتی مقدار n به 0 رسید، کنترل برنامه از دستور while خارج می‌شود و کلمه Blastoff را نمایش می‌دهد!\nساختار استفاده از عبارت while به شرح زیر است:\nاین نوع جریان حلقه نامیده می‌شود زیرا در مرحله سوم به سمت بالا باز می‌گردد. هر بار که بدنه حلقه را اجرا می‌کنیم، آن را یک تکرار می‌نامیم. برای حلقه بالا، می‌گوییم: «پنج تکرار داشت»، یعنی بدنه حلقه پنج بار اجرا شده است.\nبدنه حلقه باید مقدار یک یا چند متغیر را تغییر دهد تا در نهایت شرط نادرست شود و حلقه خاتمه یابد.\nما متغیری را که هر بار که حلقه اجرا می‌شود و مقدار متغیر تغییر می‌کند، فراخوانی می‌کنیم و نیز زمانی که حلقه، مقدار متغیر تکرار را به پایان می‌رساند، اگر متغیر تکراری وجود نداشته باشد، حلقه برای همیشه تکرار می‌شود و در نتیجه یک حلقه بی نهایت ایجاد می‌شود.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>تکرار</span>"
    ]
  },
  {
    "objectID": "chapter/05-iteration.html#while-iteration",
    "href": "chapter/05-iteration.html#while-iteration",
    "title": "تکرار",
    "section": "",
    "text": "n = 5\nwhile n &gt; 0:\n    print(n)\n    n = n - 1\n\nprint('Blastoff!')\n5\n4\n3\n2\n1\nBlastoff!\n\n\n\n\nشرایط را ارزیابی کنید، درست یا غلط را نشان دهید.\nاگر شرط نادرست است، از دستور while خارج شده و در دستور بعدی اجرا را ادامه دهید.\nاگر شرط درست است، بدنه را اجرا کنید و سپس به مرحله 1 برگردید.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>تکرار</span>"
    ]
  },
  {
    "objectID": "chapter/05-iteration.html#infinite-loops",
    "href": "chapter/05-iteration.html#infinite-loops",
    "title": "تکرار",
    "section": "حلقه‌های بی‌نهایت",
    "text": "حلقه‌های بی‌نهایت\nدر مورد شمارش معکوس، می‌توانیم ثابت کنیم که حلقه خاتمه می‌یابد زیرا می‌دانیم که مقدار n محدود است و می‌بینیم که مقدار n هر بار از طریق حلقه کوچکتر می‌شود، بنابراین در نهایت باید به 0 برسیم. در سایر مواقع، یک حلقه بی‌نهایت Infinite loops است زیرا هیچ متغیر تکراری ندارد (به شبه شرط منطقی داخل پرانتز در عبارت break دقت کنید).\nکاربرد حلقه بی‌نهایت در این است که برخی اوقات تا زمانی که نیمی از بدنه را طی نکنیم، نمی‌دانیم آیا زمان پایان دادن به یک حلقه فرا رسیده است. در این صورت می‌توانیم یک حلقه بی‌نهایت را عمداً بنویسیم و سپس از دستور break برای پرش از حلقه استفاده کنیم.\nn = 10\nwhile True:\n  print(n, end=' ')\n  n = n - 1\n\nprint('Done!')\nاگر مرتکب اشتباه شویم و این کد را اجرا کنیم، یاد خواهیم گرفت که چگونه فرآیند و یا مسیر پایتون را در سیستم خود متوقف کنیم و یا آن را خاتمه دهیم. این برنامه برای همیشه یا تا زمانی که باتری ما تمام شود اجرا می‌شود زیرا عبارت منطقی در بالای حلقه به دلیل این که عبارت مقدار ثابت True است همیشه درست است.\nمثال زیر، کاربرد break را به خوبی نشان می‌دهد:\nwhile True:\n    line = input('&gt; ')\n    if line == 'done':\n        break\n    print(line)\nprint('Done!')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>تکرار</span>"
    ]
  },
  {
    "objectID": "chapter/05-iteration.html#continue-iteration",
    "href": "chapter/05-iteration.html#continue-iteration",
    "title": "تکرار",
    "section": "اتمام تکرار فعلی و ادامه تکرار بعدی",
    "text": "اتمام تکرار فعلی و ادامه تکرار بعدی\nگاهی اوقات ما در یک تکرار یک حلقه هستیم و می‌خواهیم تکرار فعلی را تمام کنیم و بلافاصله به تکرار بعدی برویم. در آن صورت می‌توانیم از دستور continue برای پرش به تکرار بعدی استفاده کنیم، بدون اینکه بدنه حلقه برای تکرار فعلی تمام شود.\nwhile True:\n    line = input('&gt; ')\n    if line[0] == '#':\n        continue\n    if line == 'done':\n        break\n    print(line)\nprint('Done!')",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>تکرار</span>"
    ]
  },
  {
    "objectID": "chapter/05-iteration.html#for-iteration",
    "href": "chapter/05-iteration.html#for-iteration",
    "title": "تکرار",
    "section": "حلقه‌های معین با استفاده از",
    "text": "حلقه‌های معین با استفاده از\nگاهی اوقات می‌خواهیم مجموعه‌ای از چیزها را مانند فهرستی از کلمات، خطوط یک فایل یا فهرستی از اعداد را بصورت حلقه‌ای ایجاد کنیم. وقتی لیستی از چیزهایی که باید از طریق آنها حلقه بزنیم داریم، می توانیم با استفاده از دستور for یک حلقه معین بسازیم. دستور while را یک حلقه نامعین می نامیم زیرا به سادگی حلقه می‌زند تا زمانی که برخی از شرط‌ها False شود، در حالی که حلقه for در مجموعه‌ای شناخته شده از آیتم‌ها حلقه می‌زند بنابراین به تعداد آیتم‌های مجموعه، تکرار می‌شود.\nfriends = ['Joseph', 'Glenn', 'Sally']\nfor friend in friends:\n    print('Happy New Year: ', friend)\nprint('Done!')\nHappy New Year:  Joseph\nHappy New Year:  Glenn\nHappy New Year:  Sally\nDone!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>تکرار</span>"
    ]
  },
  {
    "objectID": "chapter/06-string.html",
    "href": "chapter/06-string.html",
    "title": "رشته‌ها",
    "section": "",
    "text": "محاسبه طول متن\nlen یک تابع داخلی در پایتون است که تعداد کاراکترهای یک رشته را برمی‌گرداند.\nحال اگر این عدد را به عنوان اندیس متغیر رشته استفاده کنیم، آخرین کاراکتر رشته را بدست می‌آوریم:\nدلیل این تفریق این است که شماره اندیس اولین کاراکتر رشته، با صفر شروع می‌شود.\nبنابراین برای دستیابی به موقعیت‌های دیگر یک رشته، می‌توان اندیس‌ها را تغییر داد:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>رشته‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/06-string.html#string-length",
    "href": "chapter/06-string.html#string-length",
    "title": "رشته‌ها",
    "section": "",
    "text": "fruit = 'banana'\nlength = len(fruit)\n\nlast = fruit[length - 1]\nprint(last)\na\n\n\nfruit = 'banana'\nfruit[:3]\nana",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>رشته‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/06-string.html#immutable-string",
    "href": "chapter/06-string.html#immutable-string",
    "title": "رشته‌ها",
    "section": "رشته‌ها تغییرناپذیرند",
    "text": "رشته‌ها تغییرناپذیرند\nدرعین حال اینکه می‌توان به همه کاراکترهای یک رشته دست پیدا کرد، اما نمی‌توان کاراکتر دیگری را جایگزین یکی از کاراکترهای رشته کرد:\ngreeting = 'Hello, world!'\ngreeting[0] = 'J'\nاگر این دستور را اجرا کنید، با خطا مواجه می‌شوید، چراکه رشته‌ها قابل تغییر نیستند.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>رشته‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/06-string.html#in-operation",
    "href": "chapter/06-string.html#in-operation",
    "title": "رشته‌ها",
    "section": "عملگر in",
    "text": "عملگر in\nگاربرد این عملگر زمانی است که می‌خواهیم بدانیم آیا یک رشته حاوی یک رشته و یا کاراکتر خاصی هست یا خیر:\n'a' in 'banana'\nو یا این حالت:\n'seed' in 'banana'\nهمچنین با استفاده از عملگرهای &lt; و &gt; می‌توانیم رشته‌ها را از نظر ترتیب حروف الفبا با یکدیگر مقایسه کنیم:\nif word &lt; 'banana':\n  print('Your word,' + word + ', comes before banana.')\nelif word &gt; 'banana':\n  print('Your word,' + word + ', comes after banana.')\nelse:\n  print('All right, bananas.')",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>رشته‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/06-string.html#string-methods",
    "href": "chapter/06-string.html#string-methods",
    "title": "رشته‌ها",
    "section": "متدهای رشته‌ای",
    "text": "متدهای رشته‌ای\n]\nپایتون تابعی به نام dir دارد که متدهای مربوط به یک شیئ را لیست می‌کند و همچنین با استفاده از type می‌توانیم نوع شیئ را تشخیص دهیم:\nstuff = 'Hello world'\ntype(stuff)\n&lt;class 'str'&gt;\ndir(stuff)\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\nروش دیگر برای یافتن موقعیت یک زیررشته و یا یک کاراکتر خاص در یک رشته اصلی، استفاده از متد [find]{dir-ltr} می‌باشد:\nword = 'banana'\nindex = word.find('a')\nprint(index)\n1\nخوب است با متدهای strip و startwith و\nlower\nبرای آشنایی بیشتر با متدهای رشته‌ای، در برنامه پایتون خودمان تمرین کنیم.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>رشته‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/06-string.html#format-operator",
    "href": "chapter/06-string.html#format-operator",
    "title": "رشته‌ها",
    "section": "عملگر فرمت",
    "text": "عملگر فرمت\nعملگر format %، به ما اجازه می‌دهد تا رشته‌ها را بسازیم و بخش‌هایی از رشته‌ها را با داده‌های ذخیره شده در متغیرها جایگزین کنیم:\ncamels = 42\n'%d' % camels\n'42'\nدر مثال بالا توانستیم حروف 4 و 2 را به عدد 42 تبدیل کنیم.\nd مخفف “اعشاری” است. و یا این مثال:\ncamels = 42\n'I have spotted %d camels.' % camels\n'I have spotted 42 camels.'\nبه همین ترتیب، عملگرهای %g و %s وظیفه قالب‌بندی یک عدد ممیز شناور و قالب‌بندی یک رشته را به عهده دارند:\nfmt_string = 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')\n\nprint(fmt_string)\n'In 3 years I have spotted 0.1 camels.'\nیک شکل جدید از قالب رشته‌ای در نسخه‌های جدید پایتون استفاده از f'' یا همان f-string است.\nage = 27\nname = \"Mohsen\"\n\ntext = f\"Mr {name} is {age} years old.\"\nprint(text)\nMr Mohsen is 27 years old.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>رشته‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/07-files.html",
    "href": "chapter/07-files.html",
    "title": "فایل‌ها",
    "section": "",
    "text": "بازکردن فایل\nممکن است داده‌های ما از قبل در فایلی موجود باشد (دانلود فایل) ، در اینصورت باید بتوانیم آن را باز کنیم:\nاگر باز کردن موفقیت‌آمیز باشد، سیستم‌عامل یک handle برای فایل به ما برمی‌گرداند. handle، داده‌های واقعی موجود در فایل نیست، اما در عوض یک handle است که می‌توانیم برای خواندن داده‌ها از آن استفاده کنیم. اگر فایل درخواستی وجود داشته باشد و مجوزهای لازم برای خواندن فایل را داشته باشیم، به ما یک handle داده می شود.\nاما چنانچه فایل وجود نداشته باشد، اجرای این دستور ناموفق خواهد بود و handle نخواهیم داشت:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>فایل‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/07-files.html#open-file",
    "href": "chapter/07-files.html#open-file",
    "title": "فایل‌ها",
    "section": "",
    "text": "fhand = open('mbox.txt')\nprint(fhand)\n&lt;_io.TextIOWrapper name='mbox.txt' mode='r' encoding='UTF-8'&gt;\n\n\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFileNotFoundError: [Errno 2] No such file or directory: 'mbox.txt'",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>فایل‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/07-files.html#read-file",
    "href": "chapter/07-files.html#read-file",
    "title": "فایل‌ها",
    "section": "خواندن فایل",
    "text": "خواندن فایل\nبا بازکردن فایل، تنها یک handle در اختیار خواهیم داشت تا بتوانیم با استفاده از آن با فایل موردنظر کار کنیم. بنابریان برای خواندن فایل، می‌بایست با یک دستور حلقه for ساده، اقدام به خواندن فایل کنیم:\nfhand = open('mbox.txt')\ncount = 0\nfor line in fhand:\n    count = count + 1\nprint('Line Count:', count)\nLine Count: 7\nبا این دستورات، ما سعی کرده‌ایم که فایل را خط به خط بخوانیم. اما این طریقه خواندن برای فایل‌های بزرگ مورد استفاده قرار می‌گیرد. اگر فایلی داشته باشیم و بدانیم حجم آن کم است، می‌توانیم از دستورات زیر استفاده کنیم:\nfhand = open('mbox.txt')\ninp = fhand.read()\nprint(len(inp))\n334\nprint(inp[:20])\nFrom stephen.marquar\nدر این حالت بهتر است رشته خوانده شده از فایل را در یک متغیر ذخیره کنیم، چراکه با خواندن فایل بعدی به همین روش، محتویات فایل قبلی را از دست خواهیم داد، به همین دلیل ما از متغیر inp در دستورات فوق استفاده کردیم.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>فایل‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/07-files.html#search-in-file",
    "href": "chapter/07-files.html#search-in-file",
    "title": "فایل‌ها",
    "section": "جستجو در فایل",
    "text": "جستجو در فایل\nاگر در فایل محتویات داده به دنبال کلمه و یا داده خاصی هستیم، می‌توانیم آن را در فایلی که از قبل آن را باز کرده و خوانده‌ایم، جستجو کنیم:\nfhand = open('mbox.txt')\ncount = 0\nfor line in fhand:\n    line = line.rstrip()\n    if line.startswith('From:'):\n        print(line)\nFrom: stephen.marquard@uct.ac.za\nدر این مثال، ما به دنبال کلمه 'From' هستیم.\nما با استفاده از تابع rstrip() فضای خالی را در سمت راست رشته موجود در فایل، حذف کرده‌ایم.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>فایل‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/07-files.html#select-file",
    "href": "chapter/07-files.html#select-file",
    "title": "فایل‌ها",
    "section": "انتخاب نام فایل",
    "text": "انتخاب نام فایل\nاین مسئله برای ما پیش آمده که برای باز کردن یک فایل، همیشه نام و آدرس دقیق آن را نمی‌دانیم و نیاز است تا بتوانیم در مرورگر سیستم فایل خود، آن را جستجو کنیم. به این منظور، با استفاده از قطعه کد زیر، این امکان را به کاربر می‌دهیم که فایل موردنظر خود را ابتدا جستجو و سپس باز کند. در اینصورت ما دیگر نام فایل را بصورت مستقیم در کد خود نخواهیم داشت:\nfname = input('Enter the file name: ')\nfhand = open(fname)\ncount = 0\nfor line in fhand:\n    if line.startswith('Subject:'):\n        count = count + 1\nprint('There were', count, 'subject lines in', fname)\nEnter the file name: mbox.txt\nThere were 1 subject lines in mbox.txt",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>فایل‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/07-files.html#try-except-open-file",
    "href": "chapter/07-files.html#try-except-open-file",
    "title": "فایل‌ها",
    "section": "استفاده از try، except و open",
    "text": "استفاده از try، except و open\nاز کد قبل به خاطر داریم که ما به کاربر اجازه دادیم که نام فایل حود را برای بازکردن، انتخاب نماید. حال اگر کاربر ما چیزی را تایپ کند که نام فایل نیست چه؟ بنابراین باید تمهیداتی برای این کار بیاندیشیم، چرا که گذشته از اینکه بازکردن یک فایل غیرمرتبط برنامه را با خطا مواجه می‌کند، ممکن است فایلی که کاربر آن را انتخاب کرده، عمداً و یا سهواً برای برنامه ما ضرر داشته باشد. بنابراین ما با استفاده از دستورات try ، except و open این اتفاق را مدیریت می‌کنیم:\nfname = input('Enter the file name: ')\ntry:\n    fhand = open(fname)\nexcept:\n    print('File cannot be opened:', fname)\n    exit()\ncount = 0\nfor line in fhand:\n    if line.startswith('Subject:'):\n      count = count + 1\nprint('There were', count, 'subject lines in', fname)\nEnter the file name: otherfile.txt\nFile cannot be opened: otherfile.txt\nThere were 0 subject lines in otherfile.txt\nهمانطور که مشاهده می‌شود، تابع exit() درصورت اینکه کاربر چیزی غیر از فایل را درخواست داده باشد، برنامه ما از اجرا خارج می‌شود.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>فایل‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/07-files.html#write-file",
    "href": "chapter/07-files.html#write-file",
    "title": "فایل‌ها",
    "section": "نوشتن در فایل",
    "text": "نوشتن در فایل\nبیشتر اوقات افراد نیاز دارند که در فایل داده خود، ویرایش انجام داده یا داده جدیدی به آن بیافزایند. بنابراین باید قادر باشند که با استفاده از دستورات لازم، این کار را انجام دهند. اما یک نکته متفاوت اینجا مطرح می‌شود، به این قطعه کد توجه کنید:\nfout = open('output.txt', 'w')\nprint(fout)\n&lt;_io.TextIOWrapper name='output.txt' mode='w' encoding='UTF-8'&gt;\nدر اینجا چنانچه فایل موردنظر وجود داشته باشد، فایل باز شده و آماده نوشتن می‌باشد: در واقع پارمتر ‘w’ این اجازه را صادر می‌کند. اما اگر فایل موجود نباشد، یک فایل جدید با نام ذکر شده، ایجاد می‌شود و آماده نوشتن خواهد بود.\nمثلاً فرض کنیم می‌خواهیم متن زیر را در فایل بنویسیم:\nThis here's the wattle\nکد لازم برای این کار، به شکل زیر خواهد بود:\nline1 = \"This here's the wattle,\\n\"\nfout.write(line1)\n24\nو درنهایت اینکه وقتی کارمان با فایلی تمام شد، می‌بایست حتماً آن را ببندیم:\nfout.close()",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>فایل‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/08-lists.html",
    "href": "chapter/08-lists.html",
    "title": "لیست‌ها",
    "section": "",
    "text": "لیست یک دنباله است\nبرای کنارهم قرار دادن چندین داده با نوع مختلف، می‌توان از لیست استفاده کرد. یکی از راه‌های ایجاد لیست، بکاربردن براکت در تعریف آن است:\nاما همانطور که گفته بودیم، عناصر لیست می‌توانند نوع‌های متفاوت از هم داشته باشند:\nدر دو مثال قبلی؛ تعداد عناصر لیست را به این شکل محاسبه می‌کنیم:\nلیست cheeses دارای 3 عنصر است. لیست numbers دو عنصر دارد و لیست multi_types_items شامل 4 عنصر می‌شود. چراکه لیست داخلی که شامل عناصر 10 و 20 هست، در لیست اصلی، به عنوان یک عنصر و یا داده درنظرگرفته می‌شود.\nبرای تغییر مقادیر موجود در لیست، می‌بایست بتوانیم به هر داده دسترسی داشته باشیم، به این منظور از اندیس برای آدرس‌دهی استفاده می‌کنیم:\nو یا برای اینکه بدانیم داده مورد نظر ما در لیست قرار گرفته یا خیر، می‌توان از این روش استفاده کرد:\nو یا:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>لیست‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/08-lists.html#a-list-is-a-sequence",
    "href": "chapter/08-lists.html#a-list-is-a-sequence",
    "title": "لیست‌ها",
    "section": "",
    "text": "cheeses = ['Cheddar', 'Edam', 'Gouda']\nnumbers = [17, 123]\nempty = []\nprint(cheeses, numbers, empty)\n['Cheddar', 'Edam', 'Gouda'] [17, 123] []\n\nmulti_types_items = ['spam', 2.0, 5, [10, 20]]\n\n\n\nnumbers = [17, 123]\nnumbers[1] = 5\nprint(numbers)\n[17, 5]\n\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Edam' in cheeses\nTrue\n\ncheeses = ['Cheddar', 'Edam', 'Gouda']\n'Brie' in cheeses\nFalse",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>لیست‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/08-lists.html#traversing-a-list",
    "href": "chapter/08-lists.html#traversing-a-list",
    "title": "لیست‌ها",
    "section": "پیمایش در لیست",
    "text": "پیمایش در لیست\nمواقعی هست که می‌خواهیم کل یک لیست را پیمایش کنیم و داده‌های آن را در یک عملیات محاسبه‌ای و یا هرنوع عملیات دیگر، وارد سازیم، در اینصورت:\nfor cheese in cheeses:\n    print(cheese)\nCheddar\nEdam\nGouda\nاین کار بسیار ساده بود. چرا که ما تمام لیست را یکی یکی پیمایش کردیم و آن را در خروجی چاپ کردیم. اما اگر نیاز داشته باشیم که در حین پیمایش، داده‌ای از لیست را تغییر دهیم، چه روشی را باید درپیش بگیریم؟\nfor i in range(len(numbers)):\n    numbers[i] = numbers[i] * 2",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>لیست‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/08-lists.html#work-with-list-items",
    "href": "chapter/08-lists.html#work-with-list-items",
    "title": "لیست‌ها",
    "section": "کارکردن با عناصر لیست",
    "text": "کارکردن با عناصر لیست\nدر قطعه کد زیر، به ترتیب با استفاده از عملگرهای + و * آشنا می‌شویم و سپس نحوه برش‌های مختلف لیست را یادمی‌گیریم:\na = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\nprint(c)\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\nt = ['a', 'b', 'c', 'd', 'e', 'f']\nt[1:3]\n['b', 'c']\nt[:4]\n['a', 'b', 'c', 'd']\nt[3:]\n['d', 'e', 'f']",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>لیست‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/08-lists.html#list-methods",
    "href": "chapter/08-lists.html#list-methods",
    "title": "لیست‌ها",
    "section": "متدهای لیست",
    "text": "متدهای لیست\nبرای اضافه کردن یک عنصر به انتهای لیست، می‌توانیم از متد append() استفاده کنیم:\nt = ['a', 'b', 'c']\nt.append('d')\nprint(t)\n['a', 'b', 'c', 'd']\nهمچنین متد extend() یک لیست را به عنوان آرگومان ورودی دریافت می‌کند و آن را به انتهای لیست معرفی شده، اضافه می‌کند:\nt1 = ['a', 'b', 'c']\nt2 = ['d', 'e']\nt1.extend(t2)\nprint(t1)\n['a', 'b', 'c', 'd', 'e']\nبرای مرتب کردن عناصر یک لیست، متد sort() در اختیار ماست:\nt = ['d', 'c', 'e', 'b', 'a']\nt.sort()\nprint(t)\n['a', 'b', 'c', 'd', 'e']\nاگر چنانچه خواسته باشیم عنصری را از داخل یک لیست حذف کنیم، با دانستن اندیس موقعیت آن عنصر، می‌توانیم از متد ‘pop(i)’ استفاده کنیم:\nt = ['a', 'b', 'c']\nx = t.pop(1)\nprint(t)\n['a', 'c']\nprint(x)\nb\nاگر در استفاده از دستور pop() اندیس استفاده نشود، این متد، آخرین عنصر آرایه را حذف خواهد کرد.\nبه کد زیر و نتیجه اجرای آن دقت کنید:\nt = ['a', 'b', 'c']\ndel t[1]\nprint(t)\n['a', 'c']\nبه نظر شما تفاوت استفاده از متدهای pop(i) و del list_name[i] در چیست؟\nبله، درست است که هر دو باعث حذف یک عنصر از لیست می‌شوند اما در استفاده از متد pop(i) عنصر حذف شده در اختیار ما خواهد بود. به این معنی که خروجی این متد، نمایانگر مقدار عنصر حذف شده است. اما در استفاده از دستور del list_name[i] عنصری که حذف شده دیگر در دسترس ما نخواهد بود.\nحال به این سوال فکر کنید که اگر اندیس عنصر موردنظر برای حذف کردن را ندانیم، از چه روشی می‌توانیم آن عنصر خاص را حذف کنیم؟ درواقع پایتون برای این منظور متد remove(item_value) را پیشنهاد می‌دهد که با ارسال مقدار عنصر موردنظر به عنوان آرگومان ورودی به این متد، می‌توانیم آن را از لیست حذف کنیم:\nt = ['a', 'b', 'c']\nt.remove('b')\nprint(t)\n['a', 'c']\nو یا برای حذف بیش از یک مقدار، با دانستن اندیس آن‌ها می‌توان از روش زیر استفاده کرد:\nt = ['a', 'b', 'c', 'd', 'e', 'f']\ndel t[1:5]\nprint(t)\n['a', 'f']",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>لیست‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/08-lists.html#important-function-for-lists",
    "href": "chapter/08-lists.html#important-function-for-lists",
    "title": "لیست‌ها",
    "section": "برخی توابع مهم مربوط به لیست",
    "text": "برخی توابع مهم مربوط به لیست\nدر کدهای زیر نام و کاربرد برخی توابع مهم برای استفاده در لیست‌ها معرفی شده‌اند:\nnums = [3, 41, 12, 9, 74, 15]\nprint(len(nums))\n6\nprint(max(nums))\n74\nprint(min(nums))\n3\nprint(sum(nums))\n154\nprint(sum(nums)/len(nums))\n25.666666666666668",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>لیست‌ها</span>"
    ]
  },
  {
    "objectID": "chapter/08-lists.html#lists-strings",
    "href": "chapter/08-lists.html#lists-strings",
    "title": "لیست‌ها",
    "section": "لیست‌ها و رشته‌ها",
    "text": "لیست‌ها و رشته‌ها\nیک رشته، دنباله‌ای از کاراکترهاست و یک لیست دنباله‌ای از عناصر. اما یک لیست از کاراکترها، همانند یک رشته نیست. برای تبدیل یک رشته به یک لیست، می‌توان از متد یا تابع list(string_name) استفاده کرد:\ns = 'spam'\nt = list(s)\nprint(t)\n['s', 'p', 'a', 'm']\nاما اگر بخواهیم رشته‌ای از کلمات را به لیست تبدیل کنیم، چه باید کرد:\ns = 'pining for the fjords'\nt = s.split()\nprint(t)\n['pining', 'for', 'the', 'fjords']\nو یا مثالی دیگر که در آن با کاربرد توابع split(delimiter) و join(list_name) آشنا می‌شویم:\ns = 'spam-spam-spam'\ndelimiter = '-'\ns.split(delimiter)\n['spam', 'spam', 'spam']\nt = ['pining', 'for', 'the', 'fjords']\ndelimiter = ' '\ndelimiter.join(t)\n'pining for the fjords'",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>لیست‌ها</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "منابع",
    "section": "",
    "text": "[1] C.\nR. Severance, S. Blumenberg, and E. Hauser, Python for everybody:\nExploring data in python 3. North Charleston, SC, USA: CreateSpace\nIndependent Publishing Platform, 2016.\n\n\n[2] “New york university - statistic\nsoftware.” https://guides.nyu.edu/quant/statsoft\n\n\n[3] “Stack over flow - 2023 developer\nsurvey.” https://survey.stackoverflow.co/2023/",
    "crumbs": [
      "منابع"
    ]
  }
]